## Назначение  
`email_confirm` — лёгкий асинхронный модуль отправки и отслеживания подтверждения e-mail. Построен по той же схеме «глобальная очередь + один воркер», что и `db_core`, но полностью изолирован от базы данных.  

Он умеет:
- Запланировать отправку письма подтверждения на указанный адрес  
- Периодически (каждые 10 с) раз в пачке отправлять все новые письма  
- Ограничить частоту повторной отправки (30 с)  
- Отслеживать статус рассылки и подтверждения  
- Завершить работу по токену из ссылки в письме  

## Архитектура  
- **`asyncio.Queue`** создаётся единожды в модуле, доступ через `get_mail_queue()`  
- **`MailProducer`** — фасад для вашего кода, помещает задачи в очередь и ждёт результата  
- **`MailWorker`** — единственный потребитель очереди, хранит внутренние структуры и раз в 10 с шлёт пачку писем через `aiosmtplib` + `EmailMessage`  

Каждое письмо генерируется с уникальным `token` и ссылкой  

[https://example.com/confirm?token=](https://example.com/confirm?token=)<token>

## Конфигурация  
| Константа       | Описание                                              |
|-----------------|-------------------------------------------------------|
| `BATCH_INTERVAL`| интервал между попытками отправки пачки, сек (10)     |
| `RESEND_WINDOW` | минимальная пауза перед повторной отправкой, сек (30) |
| `SMTP_HOST`     | SMTP-сервер (smtp.gmail.com)                         |
| `SMTP_PORT`     | порт SMTP (587)                                       |
| `SMTP_USER`     | учётная запись отправителя                            |
| `SMTP_PASS`     | пароль (рекомендуется из `env["SMTP_PASS"]`)         |
| `BASE_URL`      | URL конца подтверждения, ожидает параметр `token`     |

## Публичные методы класса `MailProducer`  

| Метод                     | Описание                                                          | Аргументы             | Возврат                |
|---------------------------|-------------------------------------------------------------------|-----------------------|------------------------|
| `email_confirm(email)`    | Запланировать отправку письма подтверждения на `email`            | `email: str`          | `True` или `False`     |
| `is_confirm(email)`       | Получить статус рассылки и подтверждения                          | `email: str`          | `dict` или `None`      |
| `mark_confirmed(token)`   | Завершить подтверждение по `token` из ссылки в письме             | `token: str`          | `True` или `False`     |

### Формат результата `is_confirm`  
```json
{
  "sent": 0|1,      // отправлено ли письмо хотя бы раз
  "timer": N,       // секунд до разрешённой повторной отправки (0 → можно снова вызвать email_confirm)
  "confirmed": 0|1  // подтверждён ли адрес
}
```

## Внутреннее поведение `MailWorker`

1. **На `request`**

   * Если записи нет или она устарела (прошло ≥ RESEND\_WINDOW после последней отправки), создаёт новую с полем `token` и сбросом флага `sent=False`.
   * Если письмо уже отправлено и окно не истекло → возвращает `False`.
2. **Пачковая отправка** каждые BATCH\_INTERVAL секунд:

   * Собирает все адреса с `sent=False` и `confirmed=False`
   * Открывает одно SMTP-соединение, шлёт все письма `EmailMessage` в HTML-формате
   * После отправки помечает `sent=True` и сохраняет метку времени
3. **На `status`**

   * Отдаёт текущее состояние `{sent,timer,confirmed}`
   * Если `confirmed==1`, очищает внутренние записи
4. **На `confirm`**

   * Ищет `email` по присланному `token`, помечает `confirmed=True`

## Пример использования

```python
import asyncio, os
from email_confirm import MailWorker, MailProducer

# задать пароль заранее или через окружение
os.environ["SMTP_PASS"] = "APPLESS_PASSWORD"

async def main():
    # запустить одного воркера
    asyncio.create_task(MailWorker().run())
    producer = MailProducer()

    # шаг 1: запросить отправку
    ok = await producer.email_confirm("alice@example.com")
    print("запрос отправки:", ok)  

    # каждые 5 с проверяем статус и выводим
    for _ in range(7):
        st = await producer.is_confirm("alice@example.com")
        print("статус:", st)
        await asyncio.sleep(5)

    # шаг 2: когда пользователь получил письмо и перешёл по ссылке,
    # ваш HTTP-эндпоинт вызывает:
    #   await producer.mark_confirmed(token)
    # здесь имитируем вызов:
    fake_token = input("введите токен из ссылки: ")
    confirmed = await producer.mark_confirmed(fake_token)
    print("подтверждение выполнено:", confirmed)

    # проверим ещё раз — запись должна исчезнуть
    st2 = await producer.is_confirm("alice@example.com")
    print("после подтверждения:", st2)

asyncio.run(main())
```
